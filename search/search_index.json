{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Table of Contents The laboratory of course Computational Thinking and Programming includes practical exercises in Python.","title":"Home"},{"location":"index.html#table-of-contents","text":"The laboratory of course Computational Thinking and Programming includes practical exercises in Python.","title":"Table of Contents"},{"location":"about.html","text":"Course description Computation plays an essential role in today's world. Understanding computation lies at the heart of many scientific and social developments. This course will discuss computation's power and limitations, including what is computable and how efficient a solution is. Computational thinking skill set go beyond programming a computer, as it can be applied to any field that requires problem-solving abilities \u2014 it is all about thinking about abstractions. It has become a fundamental skill for everyone and a tool for understanding the technology that pervades our social world. Likewise, computational thinking increases our awareness of how everyday digital tools work, grounds our cyber ethics, and improves our resilience against various threats, such as algorithm-driven attempts to guide our behavior, personally tailored fake news, viral powers of social media, and massive data-intensive analysis of our movements. It is a powerful but not universal approach to problem-solving, as the ability to solve a problem depends on understanding the context in which the problem exists. For instance, one must understand fluid dynamics to build a simulation of aircraft in flight, or one must understand the genome's biology and the data collection methods to develop a program to search genome databases.","title":"About"},{"location":"about.html#course-description","text":"Computation plays an essential role in today's world. Understanding computation lies at the heart of many scientific and social developments. This course will discuss computation's power and limitations, including what is computable and how efficient a solution is. Computational thinking skill set go beyond programming a computer, as it can be applied to any field that requires problem-solving abilities \u2014 it is all about thinking about abstractions. It has become a fundamental skill for everyone and a tool for understanding the technology that pervades our social world. Likewise, computational thinking increases our awareness of how everyday digital tools work, grounds our cyber ethics, and improves our resilience against various threats, such as algorithm-driven attempts to guide our behavior, personally tailored fake news, viral powers of social media, and massive data-intensive analysis of our movements. It is a powerful but not universal approach to problem-solving, as the ability to solve a problem depends on understanding the context in which the problem exists. For instance, one must understand fluid dynamics to build a simulation of aircraft in flight, or one must understand the genome's biology and the data collection methods to develop a program to search genome databases.","title":"Course description"},{"location":"chapter/01.html","text":"","title":"1. Introduction to Computational Thinking"},{"location":"chapter/02.html","text":"","title":"2. Introduction to Algorithms"},{"location":"chapter/03.html","text":"","title":"3. Introduction to Python"},{"location":"chapter/04.html","text":"","title":"4. Functions"},{"location":"chapter/05.html","text":"Data Structure Lists A list is an ordered set of elements, where each element is identified by an index. Lists are similar to strings, which are ordered sets of characters. The elements of a list can have any type. List values There are multiples way to create a list. The simplest one is to enclose the elements in square brackets ([ and ]) names = [\"Alice\", \"Sophie\", \"Mary\", \"Eve\"] ages = [20, 22, 54, 34] The first example is a list of four string values, where the second one is a list of four integers. Python provide a simple way to creare a list of consecutive integers. numbers = list(range(0, 10)) print(numbers) The range function takes two arguments and returns an object that produces a sequence of integers from the start to the stop, including the start but not the stop. If there is a third argument called step size . It specifies the increment or decrement between successives values numbers = list(range(0, 100, 2)) print(numbers) With a single argument, it creates a list that start at 0 numbers = list(range(0, 8)) print(numbers) One can also create an empty list empty = [] Acessing individual elements One can access an element of a list through the bracket operator ([]). The expression inside the brackets specifies the index. Remember that the indices start at 0 . cheeses = [\"Cheddar\", \"Edam\", \"Gouda\"] print(cheeses[1]) cheeses[2] = \"Feta\" print(cheeses) Any integer expression can be used as an index. Example print(cheeses[2-1]) If you try to use a non-integer expression, you will get a TypeError numbers[1.0] TypeError: list indices must be integers or slices, not float We get an IndexError , when trying to read or write an element that does not exist print(numbers[10]) numbers[10] = 42 IndexError: list index out of range If an index has a negative value, it counts backward from the end of the list print(numbers[-1]) numbers[-1] is the last element of the list, numbers[-2] is the second to last, \\(\\ldots\\) List membership The Boolean operator in tests the membership in a sequence . cheeses = [\"Cheddar\", \"Edam\", \"Gouda\", \"Feta\"] print(\"Edam\" in cheeses) print(\"Manouri\" in cheeses) Since Edam is a member of the list cheeses , the in operator returns True . It returns False for Manouri , since it is not a member of the list cheeses . We can combine not with in to test whether an element is not a member of the list print(\"Manouri\" not in cheeses) In this case, the output is True . Traversing a list for cheese in cheeses: print(cheese) It almost reads like English: \"for every cheese in (the list of) cheeses , print (the name of the) cheese. One can also use the enumerate function to have the index and the value when traversing a list for i, cheese in enumerate(cheeses): print(i, cheese) List operations The + operator concatenates two lists a = list(range(1, 9, 2)) b = list(range(9, 15, 2)) c = a + b print(c) Similarly, the * operator repeats a list a given number of times a = [42] * 3 print(a) b = [42, 5] * 2 print(b) The first example repeats the list [42] three times. The second one repeats the list [42, 5] two times We can also use the method extend b.extend([100, 300]) cheeses.extend([\"Feta\", \"Mozzarella\", \"Burrata\"]) We can also use the method append to add a new element to a list cheeses.append(\"Orda\") print(cheeses) The method sort arranges the elements of the list in ascending order cheeses.sort() It changes the list. Use the built-in function sorted to create a sorted version of a given list b_sorted = sorted(b) Objects and values When one assigns a variable to another, both variables will refer to the same object a = [1, 8, 10] b = a In this case, we case a list has two different names a and b . Changes made with one will affect the other. This behavior is called aliasing . b[0] = 7 print(a) # [7, 8, 10] Although this behavior can be useful, it is sometimes unexpected or undesirable. In general, it is safer to avoid aliasing when you are working with mutable objects . Cloning lists If you want to modify a list and also keep a copy of the original one, you need to work on a copy the list. This process is sometimes called cloning . The easiest way to clone a list is to use the slice operator . a = [1, 8, 10] b = a[:] print(b) Taking any slice of the list a creates a new list. In this case, the slice happens to consist the whole list. Now, you can change the list b without affecting the list a . b[0] = 7 print(a) # [1, 8, 10] List as parameters Passing a list as an argument of a function actually passes a reference to the list and not a copy of it. For example, the function head takes a list as a parameter and returns the first element: def head(list): return list[0] numbers = [1, 8, 10] head(numbers) In this case, the parameter list and the variable numbers refer to the same object. If a function modifies a list parameter, the caller sees the change. For example, the function delete_head removes the first element from a given list. def head(list): del list[0] numbers = [1, 8, 10] delete_head(numbers) print(numbers) # [8, 10] In the same context, if a function returns a list, it returns a reference to the list. Nested lists The element of a list may be another list values = [names, ages] A list with another list is said to be nested . Nested lists are often used to represent matrices. For example tha matrix: \\[ \\begin{bmatrix} 1 & 2 & 3\\\\ 4 & 5 & 6\\\\ 7 & 8 & 9\\\\ \\end{bmatrix} \\] might be represent as: matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] matrix is a list with three elements, where each element is a row of the matrix. One can select an entire row from the matrix in the usual way print(matrix[1]) The output is the entire first row [4, 5, 6]. We can also extract a single element from the matrix using the double-index format print(matrix[1][1]) The first index selects the row, and the second one selects the column. There are other type of matrix representation such as list of columns instead of a list of rows. Tuples Tuples are another kind of sequence that works much like a list Tuples have elements which are indexed starting at 0 Pretty much anything we can do to a list that doesn't change its state, we can do to a tuple We can specify a tuple by using parentheses or nothing instead of square brackets cheeses = ('Cheddar', 'Mozzarella', 'Burrata') students = ('Alice', 'Elsa', 'Mary', 'Eve') Tuples are a convenient way to return multiple values from a function Tuple contents are ordered (like an array). s = ('GOOG', 100, 490.1) name = s[0] # 'GOOG' shares = s[1] # 100 price = s[2] # 490.1 Unlike a list, once we created a tuple, we cannot alter its contents s[1] = 75 One will get the error \" TypeError: object does not support item assignment \" Tuples are more memory efficient Since Python does not have to build tuple structures to be modifiable, they are simpler and more efficient in terms of memory use and performance than lists Thus, in our program when we are making ``temporary variables'', we prefer tuples over lists Tuples are comparable The comparison operators work with tuples and other sequences (\\eg{} lists) If the first item is equal, Python goes on to the next element, and so on, until it finds elements that differ numbers = (1, 5, 8) print (numbers < (6, 10, 15)) You can, however, make a new tuple based on a current tuple. s = (s[0], 75, s[2]) Tuple Unpacking To use the tuple elsewhere, you can unpack its parts into variables. name, shares, price = s print('Cost', shares * price) The number of variables on the left must match the tuple structure. name, shares = s # ERROR Traceback (most recent call last): ... ValueError: too many values to unpack Random Numbers Numerical simulations play a fundamental role when solving real-world problems. For instance, computer simulation is used to predict the weather, aircraft design, create special effects for movies, among others. Many simulations require events to occur with a certain likelihood. These sorts of simulations are called Monte Carlo simulations because the results depend on \" chance \". A similar approach is used to generate pseudorandom numbers. A pseudorandom number generator works by starting with a seed value. This value is given to a function to output a pseudorandom number. The next time a random number is required, the current value is fed back into the function to produce a new one. This sequence of numbers appears to be random, but if you start the process over again with the same seed number, you will get the same sequence of pseudorandom numbers. Python provides a library module that contains a number of functions for working with pseudorandom numbers. These functions derive an initial seed value from the computer's date and time when the module is loaded, so each time a program is run a different sequence of random numbers is produced. The main functions are randrange and random . The randrange function The randrange function is used to select a pseudorandom int from a given range. The syntax is similar to that of the function range . import random numbers = random.randrange(1, 6) numbers2 = random.randrange(5, 105, 10) The first example return a number from 1 to 5 (i.e., [1,2,3,4,5]), whereas the second one returns a multiple of 5 between 5 and 100 inclusive. Ranges go up to, but do not include, the stopping value. Each call to randrange generates a new pseudorandom int. import random for _ in range(10): print(random.randrange(1, 6)) The value 5 comes up over half the time, demonstrating the probabilistic nature of pseudorandom numbers. Over time, this function will produce a uniform distribution, which means that all values will appear an approximately equal number of times. There is also the function randint (a, b). It returns a number in a range starting at a up to and including b . The random function The random function is used to generate pseudorandom floating point values It takes no parameters and returns values uniformly distributed between 0 and 1 (including 0 but not 1). from random import random for _ in range(10): print(random()) The choice function Python can also choose randomly from a list of alternatives from random import choice cheeses = [\"Cheddar\", \"Edam\", \"Gouda\"] cheese = choice(cheeses) It returns a option of the list. It also accepts a string as an argument. from random import choice answer = choice(\"ABCD\") print(answer) It returns a random letter from the string. One can also get the same result using the randrange function. from random import randrange answer = \"ABCD\"[randrange(4)] print(answer) Seeding and reproducibility As mentioned, the numbers generated by random number generations in computers are pseudorandom. They are determined by an initial value called a seed . Using the same seed will produce the same sequence of numbers. It is useful when you need reproducibility, especially in debugging or scientific experiments. import random random.seed(42) print(random.random()) It will produce the same \"random\" value every time with this seed. The random module is useful for general-purpose random number generations, but it is unsuitable for cryptographic purposes. For those, Python has a separate module called secrets . Exercises 1. Write a program that reads a set of integers from the user and store them in a list. The program should continue reading until the user enters the workd done. Then, it should output all the values entered by the user in ascending order. Show the answer values = [] line = input(\"Enter an integer value (done to quite): \") while line != \"done\": value = int(line) values.append(value) line = input(\"Enter an integer value (done to quite): \") values.sort() print(values) 2. Write a program that reads words from the user until the user enters a blank line. The program should output each word entered by the user exactly once. The words should be outputed in the same order they were informed. Show the answer words = [] word = input(\"Enter a word (blank line to quit): \") while word != \"\": if word not in words: words.append(word) word = input(\"Enter a word (blank line to quit): \") print(words) 3. A standard deck of playing cards contains 52 cards. Each card has one of four suits along with a value. The suits are normally spades, hearts, diamonds and clubs while the values are 2 through 10, Jack, Queen, King and Ace. Each playing card can be represented using two characters. The first character is the value of the card, with the values 2 through 9 being represented directly. The characters T, J, Q, K, and A are used to represent the values 10, Jack, Queen, King and Ace respectively. The second character is used to represent the suit of the card. It is normally a lowercase letter: s for spades, h for hearts, d for diamonds, and c for clubs. The following table provides several examples of cards and their two-character representations. Card Abbreviation Jack of spades Js Two of clubs 2c Ten of diamonds Td Ace of hearts Ah Nine of spades 9s Begin by writing a function named _create_deck_. It uses loops to create a complete deck of cards by storing the two-character abbreviations for all 52 cards into a list. Return the list of cards as the function's result. The function should not require any parameters. Write a second function named _shuffle_ that randomizes the order of the cards in a list. One technique that can be used to shuffle the cards is to visit each element in the list and swap it with another random element in the list. You must write your own loop for shuffling the cards , and you cannot make use of Python's built-in shuffle function. Use these functions to create a program that displays a deck of cards before and after it has been shuffled. A good shuffling algorithm is unbiased, meaning that every different arrangement of the elements is equally probable when the algorithm completes. While the approach described previouly in this problem suggested visiting each element in sequence and swapping it with an element at a random index, such an algorithm is biased. In particular, elements that appear later in the original list are more likely to end up later in the shuffled list. Counterintuitively, an unbiased shuffle can be achieved by visiting each element in sequence and swapping it to a random index between the position of the current element and the end of the list instead of randomly selecting any index. Show the answer from random import randrange def create_deck(): cards = [] for suit in [\"s\", \"h\", \"d\", \"c\"]: for value in list(range(2,10)) + [\"T\", \"J\", \"Q\", \"K\", \"A\"]: # Construct the card and add it to the list cards.append(value + suit) return cards def shuffle(cards): for i in range(len(cards)): # Pick a random index between the current index and the end of the list other_pos = randrange(i, len(cards)) tmp = cards[i] cards[i] = cards[other_pos] cards[other_pos] = tmp def main(): cards = create_deck() print(f\"The original deck of cards is: \\n{cards}\\n\") shuffle(cards) print(f\"The shuffled deck of cards is: \\n{cards}\\n\") # Call the main function only if this code has not been imported into another program if __name__ == \"__main__\": main()","title":"5. Searching and Sorting"},{"location":"chapter/05.html#data-structure","text":"","title":"Data Structure"},{"location":"chapter/05.html#lists","text":"A list is an ordered set of elements, where each element is identified by an index. Lists are similar to strings, which are ordered sets of characters. The elements of a list can have any type.","title":"Lists"},{"location":"chapter/05.html#list-values","text":"There are multiples way to create a list. The simplest one is to enclose the elements in square brackets ([ and ]) names = [\"Alice\", \"Sophie\", \"Mary\", \"Eve\"] ages = [20, 22, 54, 34] The first example is a list of four string values, where the second one is a list of four integers. Python provide a simple way to creare a list of consecutive integers. numbers = list(range(0, 10)) print(numbers) The range function takes two arguments and returns an object that produces a sequence of integers from the start to the stop, including the start but not the stop. If there is a third argument called step size . It specifies the increment or decrement between successives values numbers = list(range(0, 100, 2)) print(numbers) With a single argument, it creates a list that start at 0 numbers = list(range(0, 8)) print(numbers) One can also create an empty list empty = []","title":"List values"},{"location":"chapter/05.html#acessing-individual-elements","text":"One can access an element of a list through the bracket operator ([]). The expression inside the brackets specifies the index. Remember that the indices start at 0 . cheeses = [\"Cheddar\", \"Edam\", \"Gouda\"] print(cheeses[1]) cheeses[2] = \"Feta\" print(cheeses) Any integer expression can be used as an index. Example print(cheeses[2-1]) If you try to use a non-integer expression, you will get a TypeError numbers[1.0] TypeError: list indices must be integers or slices, not float We get an IndexError , when trying to read or write an element that does not exist print(numbers[10]) numbers[10] = 42 IndexError: list index out of range If an index has a negative value, it counts backward from the end of the list print(numbers[-1]) numbers[-1] is the last element of the list, numbers[-2] is the second to last, \\(\\ldots\\)","title":"Acessing individual elements"},{"location":"chapter/05.html#list-membership","text":"The Boolean operator in tests the membership in a sequence . cheeses = [\"Cheddar\", \"Edam\", \"Gouda\", \"Feta\"] print(\"Edam\" in cheeses) print(\"Manouri\" in cheeses) Since Edam is a member of the list cheeses , the in operator returns True . It returns False for Manouri , since it is not a member of the list cheeses . We can combine not with in to test whether an element is not a member of the list print(\"Manouri\" not in cheeses) In this case, the output is True .","title":"List membership"},{"location":"chapter/05.html#traversing-a-list","text":"for cheese in cheeses: print(cheese) It almost reads like English: \"for every cheese in (the list of) cheeses , print (the name of the) cheese. One can also use the enumerate function to have the index and the value when traversing a list for i, cheese in enumerate(cheeses): print(i, cheese)","title":"Traversing a list"},{"location":"chapter/05.html#list-operations","text":"The + operator concatenates two lists a = list(range(1, 9, 2)) b = list(range(9, 15, 2)) c = a + b print(c) Similarly, the * operator repeats a list a given number of times a = [42] * 3 print(a) b = [42, 5] * 2 print(b) The first example repeats the list [42] three times. The second one repeats the list [42, 5] two times We can also use the method extend b.extend([100, 300]) cheeses.extend([\"Feta\", \"Mozzarella\", \"Burrata\"]) We can also use the method append to add a new element to a list cheeses.append(\"Orda\") print(cheeses) The method sort arranges the elements of the list in ascending order cheeses.sort() It changes the list. Use the built-in function sorted to create a sorted version of a given list b_sorted = sorted(b)","title":"List operations"},{"location":"chapter/05.html#objects-and-values","text":"When one assigns a variable to another, both variables will refer to the same object a = [1, 8, 10] b = a In this case, we case a list has two different names a and b . Changes made with one will affect the other. This behavior is called aliasing . b[0] = 7 print(a) # [7, 8, 10] Although this behavior can be useful, it is sometimes unexpected or undesirable. In general, it is safer to avoid aliasing when you are working with mutable objects .","title":"Objects and values"},{"location":"chapter/05.html#cloning-lists","text":"If you want to modify a list and also keep a copy of the original one, you need to work on a copy the list. This process is sometimes called cloning . The easiest way to clone a list is to use the slice operator . a = [1, 8, 10] b = a[:] print(b) Taking any slice of the list a creates a new list. In this case, the slice happens to consist the whole list. Now, you can change the list b without affecting the list a . b[0] = 7 print(a) # [1, 8, 10]","title":"Cloning lists"},{"location":"chapter/05.html#list-as-parameters","text":"Passing a list as an argument of a function actually passes a reference to the list and not a copy of it. For example, the function head takes a list as a parameter and returns the first element: def head(list): return list[0] numbers = [1, 8, 10] head(numbers) In this case, the parameter list and the variable numbers refer to the same object. If a function modifies a list parameter, the caller sees the change. For example, the function delete_head removes the first element from a given list. def head(list): del list[0] numbers = [1, 8, 10] delete_head(numbers) print(numbers) # [8, 10] In the same context, if a function returns a list, it returns a reference to the list.","title":"List as parameters"},{"location":"chapter/05.html#nested-lists","text":"The element of a list may be another list values = [names, ages] A list with another list is said to be nested . Nested lists are often used to represent matrices. For example tha matrix: \\[ \\begin{bmatrix} 1 & 2 & 3\\\\ 4 & 5 & 6\\\\ 7 & 8 & 9\\\\ \\end{bmatrix} \\] might be represent as: matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] matrix is a list with three elements, where each element is a row of the matrix. One can select an entire row from the matrix in the usual way print(matrix[1]) The output is the entire first row [4, 5, 6]. We can also extract a single element from the matrix using the double-index format print(matrix[1][1]) The first index selects the row, and the second one selects the column. There are other type of matrix representation such as list of columns instead of a list of rows.","title":"Nested lists"},{"location":"chapter/05.html#tuples","text":"Tuples are another kind of sequence that works much like a list Tuples have elements which are indexed starting at 0 Pretty much anything we can do to a list that doesn't change its state, we can do to a tuple We can specify a tuple by using parentheses or nothing instead of square brackets cheeses = ('Cheddar', 'Mozzarella', 'Burrata') students = ('Alice', 'Elsa', 'Mary', 'Eve') Tuples are a convenient way to return multiple values from a function Tuple contents are ordered (like an array). s = ('GOOG', 100, 490.1) name = s[0] # 'GOOG' shares = s[1] # 100 price = s[2] # 490.1 Unlike a list, once we created a tuple, we cannot alter its contents s[1] = 75 One will get the error \" TypeError: object does not support item assignment \"","title":"Tuples"},{"location":"chapter/05.html#tuples-are-more-memory-efficient","text":"Since Python does not have to build tuple structures to be modifiable, they are simpler and more efficient in terms of memory use and performance than lists Thus, in our program when we are making ``temporary variables'', we prefer tuples over lists","title":"Tuples are more memory efficient"},{"location":"chapter/05.html#tuples-are-comparable","text":"The comparison operators work with tuples and other sequences (\\eg{} lists) If the first item is equal, Python goes on to the next element, and so on, until it finds elements that differ numbers = (1, 5, 8) print (numbers < (6, 10, 15)) You can, however, make a new tuple based on a current tuple. s = (s[0], 75, s[2])","title":"Tuples are comparable"},{"location":"chapter/05.html#tuple-unpacking","text":"To use the tuple elsewhere, you can unpack its parts into variables. name, shares, price = s print('Cost', shares * price) The number of variables on the left must match the tuple structure. name, shares = s # ERROR Traceback (most recent call last): ... ValueError: too many values to unpack","title":"Tuple Unpacking"},{"location":"chapter/05.html#random-numbers","text":"Numerical simulations play a fundamental role when solving real-world problems. For instance, computer simulation is used to predict the weather, aircraft design, create special effects for movies, among others. Many simulations require events to occur with a certain likelihood. These sorts of simulations are called Monte Carlo simulations because the results depend on \" chance \". A similar approach is used to generate pseudorandom numbers. A pseudorandom number generator works by starting with a seed value. This value is given to a function to output a pseudorandom number. The next time a random number is required, the current value is fed back into the function to produce a new one. This sequence of numbers appears to be random, but if you start the process over again with the same seed number, you will get the same sequence of pseudorandom numbers. Python provides a library module that contains a number of functions for working with pseudorandom numbers. These functions derive an initial seed value from the computer's date and time when the module is loaded, so each time a program is run a different sequence of random numbers is produced. The main functions are randrange and random .","title":"Random Numbers"},{"location":"chapter/05.html#the-randrange-function","text":"The randrange function is used to select a pseudorandom int from a given range. The syntax is similar to that of the function range . import random numbers = random.randrange(1, 6) numbers2 = random.randrange(5, 105, 10) The first example return a number from 1 to 5 (i.e., [1,2,3,4,5]), whereas the second one returns a multiple of 5 between 5 and 100 inclusive. Ranges go up to, but do not include, the stopping value. Each call to randrange generates a new pseudorandom int. import random for _ in range(10): print(random.randrange(1, 6)) The value 5 comes up over half the time, demonstrating the probabilistic nature of pseudorandom numbers. Over time, this function will produce a uniform distribution, which means that all values will appear an approximately equal number of times. There is also the function randint (a, b). It returns a number in a range starting at a up to and including b .","title":"The randrange function"},{"location":"chapter/05.html#the-random-function","text":"The random function is used to generate pseudorandom floating point values It takes no parameters and returns values uniformly distributed between 0 and 1 (including 0 but not 1). from random import random for _ in range(10): print(random())","title":"The random function"},{"location":"chapter/05.html#the-choice-function","text":"Python can also choose randomly from a list of alternatives from random import choice cheeses = [\"Cheddar\", \"Edam\", \"Gouda\"] cheese = choice(cheeses) It returns a option of the list. It also accepts a string as an argument. from random import choice answer = choice(\"ABCD\") print(answer) It returns a random letter from the string. One can also get the same result using the randrange function. from random import randrange answer = \"ABCD\"[randrange(4)] print(answer)","title":"The choice function"},{"location":"chapter/05.html#seeding-and-reproducibility","text":"As mentioned, the numbers generated by random number generations in computers are pseudorandom. They are determined by an initial value called a seed . Using the same seed will produce the same sequence of numbers. It is useful when you need reproducibility, especially in debugging or scientific experiments. import random random.seed(42) print(random.random()) It will produce the same \"random\" value every time with this seed. The random module is useful for general-purpose random number generations, but it is unsuitable for cryptographic purposes. For those, Python has a separate module called secrets .","title":"Seeding and reproducibility"},{"location":"chapter/05.html#exercises","text":"1. Write a program that reads a set of integers from the user and store them in a list. The program should continue reading until the user enters the workd done. Then, it should output all the values entered by the user in ascending order. Show the answer values = [] line = input(\"Enter an integer value (done to quite): \") while line != \"done\": value = int(line) values.append(value) line = input(\"Enter an integer value (done to quite): \") values.sort() print(values) 2. Write a program that reads words from the user until the user enters a blank line. The program should output each word entered by the user exactly once. The words should be outputed in the same order they were informed. Show the answer words = [] word = input(\"Enter a word (blank line to quit): \") while word != \"\": if word not in words: words.append(word) word = input(\"Enter a word (blank line to quit): \") print(words) 3. A standard deck of playing cards contains 52 cards. Each card has one of four suits along with a value. The suits are normally spades, hearts, diamonds and clubs while the values are 2 through 10, Jack, Queen, King and Ace. Each playing card can be represented using two characters. The first character is the value of the card, with the values 2 through 9 being represented directly. The characters T, J, Q, K, and A are used to represent the values 10, Jack, Queen, King and Ace respectively. The second character is used to represent the suit of the card. It is normally a lowercase letter: s for spades, h for hearts, d for diamonds, and c for clubs. The following table provides several examples of cards and their two-character representations. Card Abbreviation Jack of spades Js Two of clubs 2c Ten of diamonds Td Ace of hearts Ah Nine of spades 9s Begin by writing a function named _create_deck_. It uses loops to create a complete deck of cards by storing the two-character abbreviations for all 52 cards into a list. Return the list of cards as the function's result. The function should not require any parameters. Write a second function named _shuffle_ that randomizes the order of the cards in a list. One technique that can be used to shuffle the cards is to visit each element in the list and swap it with another random element in the list. You must write your own loop for shuffling the cards , and you cannot make use of Python's built-in shuffle function. Use these functions to create a program that displays a deck of cards before and after it has been shuffled. A good shuffling algorithm is unbiased, meaning that every different arrangement of the elements is equally probable when the algorithm completes. While the approach described previouly in this problem suggested visiting each element in sequence and swapping it with an element at a random index, such an algorithm is biased. In particular, elements that appear later in the original list are more likely to end up later in the shuffled list. Counterintuitively, an unbiased shuffle can be achieved by visiting each element in sequence and swapping it to a random index between the position of the current element and the end of the list instead of randomly selecting any index. Show the answer from random import randrange def create_deck(): cards = [] for suit in [\"s\", \"h\", \"d\", \"c\"]: for value in list(range(2,10)) + [\"T\", \"J\", \"Q\", \"K\", \"A\"]: # Construct the card and add it to the list cards.append(value + suit) return cards def shuffle(cards): for i in range(len(cards)): # Pick a random index between the current index and the end of the list other_pos = randrange(i, len(cards)) tmp = cards[i] cards[i] = cards[other_pos] cards[other_pos] = tmp def main(): cards = create_deck() print(f\"The original deck of cards is: \\n{cards}\\n\") shuffle(cards) print(f\"The shuffled deck of cards is: \\n{cards}\\n\") # Call the main function only if this code has not been imported into another program if __name__ == \"__main__\": main()","title":"Exercises"}]}