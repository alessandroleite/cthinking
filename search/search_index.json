{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Computation plays an essential role in today's world. Understanding computation lies at the heart of many scientific and social developments. This course will discuss computation's power and limitations, including what is computable and how efficient a solution is. Computational thinking skill set go beyond programming a computer, as it can be applied to any field that requires problem-solving abilities \u2014 it is all about thinking about abstractions. It has become a fundamental skill for everyone and a tool for understanding the technology that pervades our social world. Likewise, computational thinking increases our awareness of how everyday digital tools work, grounds our cyber ethics, and improves our resilience against various threats, such as algorithm-driven attempts to guide our behavior, personally tailored fake news, viral powers of social media, and massive data-intensive analysis of our movements. It is a powerful but not universal approach to problem-solving, as the ability to solve a problem depends on understanding the context in which the problem exists. For instance, one must understand fluid dynamics to build a simulation of aircraft in flight, or one must understand the genome's biology and the data collection methods to develop a program to search genome databases.","title":"Home"},{"location":"about.html","text":"Course description Computation plays an essential role in today's world. Understanding computation lies at the heart of many scientific and social developments. This course will discuss computation's power and limitations, including what is computable and how efficient a solution is. Computational thinking skill set go beyond programming a computer, as it can be applied to any field that requires problem-solving abilities \u2014 it is all about thinking about abstractions. It has become a fundamental skill for everyone and a tool for understanding the technology that pervades our social world. Likewise, computational thinking increases our awareness of how everyday digital tools work, grounds our cyber ethics, and improves our resilience against various threats, such as algorithm-driven attempts to guide our behavior, personally tailored fake news, viral powers of social media, and massive data-intensive analysis of our movements. It is a powerful but not universal approach to problem-solving, as the ability to solve a problem depends on understanding the context in which the problem exists. For instance, one must understand fluid dynamics to build a simulation of aircraft in flight, or one must understand the genome's biology and the data collection methods to develop a program to search genome databases.","title":"Course description"},{"location":"about.html#course-description","text":"Computation plays an essential role in today's world. Understanding computation lies at the heart of many scientific and social developments. This course will discuss computation's power and limitations, including what is computable and how efficient a solution is. Computational thinking skill set go beyond programming a computer, as it can be applied to any field that requires problem-solving abilities \u2014 it is all about thinking about abstractions. It has become a fundamental skill for everyone and a tool for understanding the technology that pervades our social world. Likewise, computational thinking increases our awareness of how everyday digital tools work, grounds our cyber ethics, and improves our resilience against various threats, such as algorithm-driven attempts to guide our behavior, personally tailored fake news, viral powers of social media, and massive data-intensive analysis of our movements. It is a powerful but not universal approach to problem-solving, as the ability to solve a problem depends on understanding the context in which the problem exists. For instance, one must understand fluid dynamics to build a simulation of aircraft in flight, or one must understand the genome's biology and the data collection methods to develop a program to search genome databases.","title":"Course description"},{"location":"chapter/01.html","text":"Introduction to Computational Thinking","title":"Introduction to Computational Thinking"},{"location":"chapter/01.html#introduction-to-computational-thinking","text":"","title":"Introduction to Computational Thinking"},{"location":"chapter/02.html","text":"Introduction to Algorithms","title":"Introduction to Algorithms"},{"location":"chapter/02.html#introduction-to-algorithms","text":"","title":"Introduction to Algorithms"},{"location":"chapter/03.html","text":"Introduction to Python","title":"Introduction to Python"},{"location":"chapter/03.html#introduction-to-python","text":"","title":"Introduction to Python"},{"location":"chapter/04.html","text":"Random numbers Numerical simulations play a fundamental role when solving real-world problems. For instance, computer simulation is used to predict the weather, aircraft design, create special effects for movies, among others. Many simulations require events to occur with a certain likelihood. These sorts of simulations are called Monte Carlo simulations because the results depend on \" chance \". A similar approach is used to generate pseudorandom numbers. A pseudorandom number generator works by starting with a seed value. This value is given to a function to output a pseudorandom number. The next time a random number is required, the current value is fed back into the function to produce a new one. This sequence of numbers appears to be random, but if you start the process over again with the same seed number, you will get the same sequence of pseudorandom numbers. Python provides a library module that contains a number of functions for working with pseudorandom numbers. These functions derive an initial seed value from the computer's date and time when the module is loaded, so each time a program is run a different sequence of random numbers is produced. The main functions are randrange and random . The randrange function The randrange function is used to select a pseudorandom int from a given range. The syntax is similar to that of the function range . import random numbers = random.randrange(1, 6) numbers2 = random.randrange(5, 105, 10) The first example return a number from 1 to 5 (i.e., [1,2,3,4,5]), whereas the second one returns a multiple of 5 between 5 and 100 inclusive. Ranges go up to, but do not include, the stopping value. Each call to randrange generates a new pseudorandom int. import random for _ in range(10): print(random.randrange(1, 6)) The value 5 comes up over half the time, demonstrating the probabilistic nature of pseudorandom numbers. Over time, this function will produce a uniform distribution, which means that all values will appear an approximately equal number of times. There is also the function randint (a, b). It returns a number in a range starting at a up to and including b . The random function The random function is used to generate pseudorandom floating point values It takes no parameters and returns values uniformly distributed between 0 and 1 (including 0 but not 1). from random import random for _ in range(10): print(random()) The choice function Python can also choose randomly from a list of alternatives from random import choice cheeses = [\"Cheddar\", \"Edam\", \"Gouda\"] cheese = choice(cheeses) It returns an element of the list. It also accepts a string as an argument. from random import choice answer = choice(\"ABCD\") print(answer) Returns a random letter from the string. One can also get the same result using the randrange function. from random import randrange answer = \"ABCD\"[randrange(4)] print(answer) Seeding and reproducibility As mentioned, the numbers generated by random number generations in computers are pseudorandom. They are determined by an initial value called a seed . Using the same seed will produce the same sequence of numbers. It is useful when you need reproducibility, especially in debugging or scientific experiments. import random random.seed(42) print(random.random()) It will produce the same \"random\" value every time with this seed. The random module is useful for general-purpose random number generations, but it is unsuitable for cryptographic purposes. For those, Python has a separate module called secrets .","title":"2. Random numbers"},{"location":"chapter/04.html#random-numbers","text":"Numerical simulations play a fundamental role when solving real-world problems. For instance, computer simulation is used to predict the weather, aircraft design, create special effects for movies, among others. Many simulations require events to occur with a certain likelihood. These sorts of simulations are called Monte Carlo simulations because the results depend on \" chance \". A similar approach is used to generate pseudorandom numbers. A pseudorandom number generator works by starting with a seed value. This value is given to a function to output a pseudorandom number. The next time a random number is required, the current value is fed back into the function to produce a new one. This sequence of numbers appears to be random, but if you start the process over again with the same seed number, you will get the same sequence of pseudorandom numbers. Python provides a library module that contains a number of functions for working with pseudorandom numbers. These functions derive an initial seed value from the computer's date and time when the module is loaded, so each time a program is run a different sequence of random numbers is produced. The main functions are randrange and random .","title":"Random numbers"},{"location":"chapter/04.html#the-randrange-function","text":"The randrange function is used to select a pseudorandom int from a given range. The syntax is similar to that of the function range . import random numbers = random.randrange(1, 6) numbers2 = random.randrange(5, 105, 10) The first example return a number from 1 to 5 (i.e., [1,2,3,4,5]), whereas the second one returns a multiple of 5 between 5 and 100 inclusive. Ranges go up to, but do not include, the stopping value. Each call to randrange generates a new pseudorandom int. import random for _ in range(10): print(random.randrange(1, 6)) The value 5 comes up over half the time, demonstrating the probabilistic nature of pseudorandom numbers. Over time, this function will produce a uniform distribution, which means that all values will appear an approximately equal number of times. There is also the function randint (a, b). It returns a number in a range starting at a up to and including b .","title":"The randrange function"},{"location":"chapter/04.html#the-random-function","text":"The random function is used to generate pseudorandom floating point values It takes no parameters and returns values uniformly distributed between 0 and 1 (including 0 but not 1). from random import random for _ in range(10): print(random())","title":"The random function"},{"location":"chapter/04.html#the-choice-function","text":"Python can also choose randomly from a list of alternatives from random import choice cheeses = [\"Cheddar\", \"Edam\", \"Gouda\"] cheese = choice(cheeses) It returns an element of the list. It also accepts a string as an argument. from random import choice answer = choice(\"ABCD\") print(answer) Returns a random letter from the string. One can also get the same result using the randrange function. from random import randrange answer = \"ABCD\"[randrange(4)] print(answer)","title":"The choice function"},{"location":"chapter/04.html#seeding-and-reproducibility","text":"As mentioned, the numbers generated by random number generations in computers are pseudorandom. They are determined by an initial value called a seed . Using the same seed will produce the same sequence of numbers. It is useful when you need reproducibility, especially in debugging or scientific experiments. import random random.seed(42) print(random.random()) It will produce the same \"random\" value every time with this seed. The random module is useful for general-purpose random number generations, but it is unsuitable for cryptographic purposes. For those, Python has a separate module called secrets .","title":"Seeding and reproducibility"},{"location":"chapter/05.html","text":"Lists, Tuples, and Dictionaries Lists A list is an ordered set of elements, where each element is identified by an index. Lists are similar to strings, which are ordered sets of characters. The elements of a list can have any type. Creating a list There are multiples way to create a list. The simplest one is to enclose the elements in square brackets ([ and ]) names = [\"Alice\", \"Sophie\", \"Mary\", \"Eve\"] ages = [20, 22, 54, 34] The first example is a list of four string values, where the second one is a list of four integers. Python provides a simple way to create a list of consecutive integers. numbers = list(range(0, 10)) print(numbers) The range function takes two arguments and returns an object that produces a sequence of integers from the start to the stop, including the start but not the stop . If there is a third argument, it determines the step size . A step size defines the increment or decrement between successive values numbers = list(range(0, 100, 2)) print(numbers) This example creates a list of integer starting from zero until 99 with a step size of two [[0, 2, 4, 6, 8, \\ldots, 98]] With calling the function range with a single argument, it creates a list starting at 0 numbers = list(range(10)) print(numbers) The output will be \\([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\\) One can also create an empty list empty = [] Accessing individual elements One can access an element of a list through the bracket operator ([]). The expression inside the brackets specifies the index. Remember that the indices start at 0 . cheeses = [\"Cheddar\", \"Edam\", \"Gouda\"] print(cheeses[1]) cheeses[2] = \"Feta\" print(cheeses) Any integer expression can be used as an index. Example print(cheeses[2-1]) If you try to use a non-integer expression, you will get a TypeError . numbers[1.0] TypeError: list indices must be integers or slices, not float We get an IndexError , when trying to read or write an element that does not exist print(numbers[10]) numbers[10] = 42 IndexError: list index out of range If an index has a negative value, it counts backward from the end of the list print(numbers[-1]) numbers[-1] is the last element of the list, numbers[-2] is the second to last, \\(\\ldots\\) Traversing a list for cheese in cheeses: print(cheese) It almost reads like English: \"for every cheese in (the list of) cheeses , print (the name of the) cheese. One can also use the enumerate function to get the index and the element when traversing a list for i, cheese in enumerate(cheeses): print(i, cheese) In this case, the variable \\(i\\) has the value of each element represented by the variable cheese List operations The + operator concatenates two lists a = list(range(1, 9, 2)) b = list(range(9, 15, 2)) c = a + b print(c) Similarly, the * operator repeats a list a given number of times a = [42] * 3 print(a) b = [42, 5] * 2 print(b) The first example repeats the list [42] three times. The second one repeats the list [42, 5] two times We can also use the method extend b.extend([100, 300]) cheeses.extend([\"Feta\", \"Mozzarella\", \"Burrata\"]) We can also use the method append to add a new element to a list cheeses.append(\"Orda\") print(cheeses) Lists are mutable Strings are immutable as one cannot change the contents of a string without creating a new one Any tentative to change the value of a string lead to a * TypeError . Example fruit = \"Banana\" fruit[0] = \"b\" In this example, we tried to change the first letter of a string to be lowercase, but we got the error: TypeError: 'str' object does not support item assignment . For this, we need to call the method lower and assign its results to the variable fruit. In other words, we need to create a new string. fruit = fruit.lower() print(fruit) Lists are mutable because one can change the order of items in a list or assign a new value to an element in a list. numbers = [42, 69, 87, 88, 95] print(numbers) # Output: [42, 69, 87, 88, 95] numbers[3] = 91 print(numbers) # Output: [42, 69, 87, 91, 95] Removing elements of a list There are several ways to delete elements from a list If index of the element to remove is known, one can use the method pop numbers = [1, 5, 8] number = numbers.pop(1) print(numbers) #Output: [1, 8] print(number) #Output: 5 The method pop modifies the list and returns the element that was removed. In other words, the method pop removes an element of a given position and returns its value. If the list is empty or the index is out of range, it raises an IndexError . If we do not provide an index, it deletes and returns the last element The example, we can read as: remove the element at the first position . If we do not need the removed value, we can use the operator del . numbers = [1, 5, 8] del numbers[1] print(numbers) #Output: [1, 8] We can use the operator del with a slice index to remove more than one element numbers = [1, 5, 8] del numbers[0:2] print(numbers) # [8] If we know the element to remove, but not the index, we can use the method remove numbers = [1, 5, 8] numbers.remove(5) print(numbers) #Output: [1, 8] List comprehensions Frequently, we need to transform a list into another one, by choosing only certain elements A way to do this in Python is through list comprehensions even_numbers = [x for x in range(10) if x % 2 == 0] squares = [x * x for x in range(10)] even_squares = [x * x for x in even_numbers] A list comprehensions can include multiple loops pairs = [(x, y)\\ for x in range(10)\\ for y in range(10)]\\ Built-in functions and lists There are a number of built-in functions that take a list as parameters Examples include max, min, sum, len, among others numbers = [8, 100, 45, 90, -1] print(\"Length:\", len(numbers)) #Output: Length: 5 print(\"Min:\", min(numbers)) #Output: Min: -1 print(\"Max:\", max(numbers)) #Output: Max: 100 print(\"Sum:\", sum(numbers)) #Output: Sum: 242 print(\"Mean:\", sum(numbers) / len(numbers)) #Output: Mean: 48.4 Lists and strings One can break a string into its parts through the method split For instance, if a string represents a text, one can see break into its words One can access a particular word or loop through all the words names = \"Alice, Sophie, Bob, Eve\" students = names.split(\",\") print(students) One might also want to join the elements of a list to represent as a single string This can be done through the method join of a string students = [\"Alice\", \"Sophie\", \"Bob\", \"Eve\"] print(\";\".join(students)) Output the name of the students separated by a semicolon. numbers = list(range(10)) print(\",\".join(str(i) for i in numbers)) Objects and values When one assigns a variable to another, both variables will refer to the same object a = [1, 8, 10] b = a In this case, we case a list has two different names a and b . Changes made with one will affect the other. This behavior is called aliasing . b[0] = 7 print(a) # [7, 8, 10] Although this behavior can be useful, it is sometimes unexpected or undesirable. In general, it is safer to avoid aliasing when you are working with mutable objects . Cloning lists If you want to modify a list and also keep a copy of the original one, you need to work on a copy the list. This process is sometimes called cloning . The easiest way to clone a list is to use the slice operator . a = [1, 8, 10] b = a[:] print(b) Taking any slice of the list a creates a new list. In this case, the slice happens to consist the whole list. Now, you can change the list b without affecting the list a . b[0] = 7 print(a) # [1, 8, 10] List as parameters Passing a list as an argument of a function actually passes a reference to the list and not a copy of it. For example, the function head takes a list as a parameter and returns the first element: def head(list): return list[0] numbers = [1, 8, 10] head(numbers) In this case, the parameter list and the variable numbers refer to the same object. If a function modifies a list parameter, the caller sees the change. For example, the function delete_head removes the first element from a given list. def delete_head(list): del list[0] numbers = [1, 8, 10] delete_head(numbers) print(numbers) # [8, 10] In the same context, if a function returns a list, it returns a reference to the list. Nested lists The element of a list may be another list values = [names, ages] A list with another list is said to be nested . Nested lists are often used to represent matrices. For example the matrix: \\[ \\begin{bmatrix} 1 & 2 & 3\\\\ 4 & 5 & 6\\\\ 7 & 8 & 9\\\\ \\end{bmatrix} \\] might be represented as: matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] matrix is a list with three elements, where each element is a row of the matrix. One can select an entire row from the matrix in the usual way print(matrix[1]) The output is the entire first row [4, 5, 6]. We can also extract a single element from the matrix using the double-index format print(matrix[1][1]) The first index selects the row, and the second one selects the column. There are other type of matrix representation such as list of columns instead of a list of rows. Tuples Tuples are another kind of sequence that works much like a list Tuples have elements which are indexed starting at 0 Pretty much anything we can do to a list that doesn't change its state, we can do to a tuple We can specify a tuple by using parentheses or nothing instead of square brackets cheeses = ('Cheddar', 'Mozzarella', 'Burrata') students = ('Alice', 'Elsa', 'Mary', 'Eve') Tuples are a convenient way to return multiple values from a function Tuple contents are ordered (like an array). s = ('GOOG', 100, 490.1) name = s[0] # 'GOOG' shares = s[1] # 100 price = s[2] # 490.1 Unlike a list, once we created a tuple, we cannot alter its contents s[1] = 75 One will get the error \" TypeError: object does not support item assignment \" Tuples are more memory efficient Since Python does not have to build tuple structures to be modifiable, they are simpler and more efficient in terms of memory use and performance than lists Thus, in our program when we are making ``temporary variables'', we prefer tuples over lists Tuples are comparable The comparison operators work with tuples and other sequences (\\eg{} lists) If the first item is equal, Python goes on to the next element, and so on, until it finds elements that differ numbers = (1, 5, 8) print (numbers < (6, 10, 15)) You can, however, make a new tuple based on a current tuple. s = (s[0], 75, s[2]) Tuple Unpacking To use the tuple elsewhere, you can unpack its parts into variables. name, shares, price = s print('Cost', shares * price) The number of variables on the left must match the tuple structure. name, shares = s # ERROR Traceback (most recent call last): ... ValueError: too many values to unpack Dictionaries A dictionary is another fundamental data structure in Python It stores information in key-value pairs It associates values with keys It enables one to quickly retrieve the value corresponding to a given key Dictionaries are like lists except that they use keys instead of numbers to look up values You can define them explicitly using key:value pairs and curly braces. mountains = {'Mount Everest': 8848, 'K2': 8611, 'Kangchenjunga': 8586} Adding new key-value pairs To add a new key-value pair, you give the dictionary a name followed by the new key in square brackets, and set that equal to the new value. mountains = dict() mountains['Mount Everest'] = 8848 mountains['K2'] = 8611 mountains['Kangchenjunga'] = 8586 Dictionaries do not store their information in any particular order, so you may not get your information back in the same order you entered it. We can get individual items out of the dictionary by giving the dictionary\u2019s name, followed by the key in square brackets: print(mountains['Mount Everest']) Dictionaries have their own for loop syntax, since there are two kinds of information in dictionaries: the key and the value. The general syntax is: for key, value in dictionary_name.items(): print(key, value) For example, for mountain, altitude in mountains.items(): print(mountain, altitude) The method items returns a list of tuples, where each tuple is a key-value pair. If you want, you can also get a list of keys of a dictionary through its method keys names = mountains.keys() Similarly, you can also get a list of values through the method values altitudes = mountains.values() If you attempt to access an entry that is not in the dictionary, Python will return an error. mountains['Lhotse'] Python will return the following error: Traceback (most recent call last): KeyError: 'Lhotse' To check if an entry is in the dictionary use the .get(key) function, which returns the value or None if the key is not in the dictionary. print(mountains.get('Lhotse')) Modifying values in a dictionary Modifying a value in a dictionary is similar to modifying an element in a list. You give the name of the dictionary and then the key in square brackets, and set that equal to the new value. mountains['Lhotse'] = 8516 Removing key-value pairs You can remove a key-value pairs from a dictionary using the same del command you learned to use with lists. In this case, you give the del command, followed by the name of the dictionary, with the key that you want to delete. This removes the key and the value as a pair. del mountains['Lhotse']","title":"1. Lists, Tuples, and Dictionaries"},{"location":"chapter/05.html#lists-tuples-and-dictionaries","text":"","title":"Lists, Tuples, and Dictionaries"},{"location":"chapter/05.html#lists","text":"A list is an ordered set of elements, where each element is identified by an index. Lists are similar to strings, which are ordered sets of characters. The elements of a list can have any type.","title":"Lists"},{"location":"chapter/05.html#creating-a-list","text":"There are multiples way to create a list. The simplest one is to enclose the elements in square brackets ([ and ]) names = [\"Alice\", \"Sophie\", \"Mary\", \"Eve\"] ages = [20, 22, 54, 34] The first example is a list of four string values, where the second one is a list of four integers. Python provides a simple way to create a list of consecutive integers. numbers = list(range(0, 10)) print(numbers) The range function takes two arguments and returns an object that produces a sequence of integers from the start to the stop, including the start but not the stop . If there is a third argument, it determines the step size . A step size defines the increment or decrement between successive values numbers = list(range(0, 100, 2)) print(numbers) This example creates a list of integer starting from zero until 99 with a step size of two [[0, 2, 4, 6, 8, \\ldots, 98]] With calling the function range with a single argument, it creates a list starting at 0 numbers = list(range(10)) print(numbers) The output will be \\([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\\) One can also create an empty list empty = []","title":"Creating a list"},{"location":"chapter/05.html#accessing-individual-elements","text":"One can access an element of a list through the bracket operator ([]). The expression inside the brackets specifies the index. Remember that the indices start at 0 . cheeses = [\"Cheddar\", \"Edam\", \"Gouda\"] print(cheeses[1]) cheeses[2] = \"Feta\" print(cheeses) Any integer expression can be used as an index. Example print(cheeses[2-1]) If you try to use a non-integer expression, you will get a TypeError . numbers[1.0] TypeError: list indices must be integers or slices, not float We get an IndexError , when trying to read or write an element that does not exist print(numbers[10]) numbers[10] = 42 IndexError: list index out of range If an index has a negative value, it counts backward from the end of the list print(numbers[-1]) numbers[-1] is the last element of the list, numbers[-2] is the second to last, \\(\\ldots\\)","title":"Accessing individual elements"},{"location":"chapter/05.html#traversing-a-list","text":"for cheese in cheeses: print(cheese) It almost reads like English: \"for every cheese in (the list of) cheeses , print (the name of the) cheese. One can also use the enumerate function to get the index and the element when traversing a list for i, cheese in enumerate(cheeses): print(i, cheese) In this case, the variable \\(i\\) has the value of each element represented by the variable cheese","title":"Traversing a list"},{"location":"chapter/05.html#list-operations","text":"The + operator concatenates two lists a = list(range(1, 9, 2)) b = list(range(9, 15, 2)) c = a + b print(c) Similarly, the * operator repeats a list a given number of times a = [42] * 3 print(a) b = [42, 5] * 2 print(b) The first example repeats the list [42] three times. The second one repeats the list [42, 5] two times We can also use the method extend b.extend([100, 300]) cheeses.extend([\"Feta\", \"Mozzarella\", \"Burrata\"]) We can also use the method append to add a new element to a list cheeses.append(\"Orda\") print(cheeses)","title":"List operations"},{"location":"chapter/05.html#lists-are-mutable","text":"Strings are immutable as one cannot change the contents of a string without creating a new one Any tentative to change the value of a string lead to a * TypeError . Example fruit = \"Banana\" fruit[0] = \"b\" In this example, we tried to change the first letter of a string to be lowercase, but we got the error: TypeError: 'str' object does not support item assignment . For this, we need to call the method lower and assign its results to the variable fruit. In other words, we need to create a new string. fruit = fruit.lower() print(fruit) Lists are mutable because one can change the order of items in a list or assign a new value to an element in a list. numbers = [42, 69, 87, 88, 95] print(numbers) # Output: [42, 69, 87, 88, 95] numbers[3] = 91 print(numbers) # Output: [42, 69, 87, 91, 95]","title":"Lists are mutable"},{"location":"chapter/05.html#removing-elements-of-a-list","text":"There are several ways to delete elements from a list If index of the element to remove is known, one can use the method pop numbers = [1, 5, 8] number = numbers.pop(1) print(numbers) #Output: [1, 8] print(number) #Output: 5 The method pop modifies the list and returns the element that was removed. In other words, the method pop removes an element of a given position and returns its value. If the list is empty or the index is out of range, it raises an IndexError . If we do not provide an index, it deletes and returns the last element The example, we can read as: remove the element at the first position . If we do not need the removed value, we can use the operator del . numbers = [1, 5, 8] del numbers[1] print(numbers) #Output: [1, 8] We can use the operator del with a slice index to remove more than one element numbers = [1, 5, 8] del numbers[0:2] print(numbers) # [8] If we know the element to remove, but not the index, we can use the method remove numbers = [1, 5, 8] numbers.remove(5) print(numbers) #Output: [1, 8]","title":"Removing elements of a list"},{"location":"chapter/05.html#list-comprehensions","text":"Frequently, we need to transform a list into another one, by choosing only certain elements A way to do this in Python is through list comprehensions even_numbers = [x for x in range(10) if x % 2 == 0] squares = [x * x for x in range(10)] even_squares = [x * x for x in even_numbers] A list comprehensions can include multiple loops pairs = [(x, y)\\ for x in range(10)\\ for y in range(10)]\\","title":"List comprehensions"},{"location":"chapter/05.html#built-in-functions-and-lists","text":"There are a number of built-in functions that take a list as parameters Examples include max, min, sum, len, among others numbers = [8, 100, 45, 90, -1] print(\"Length:\", len(numbers)) #Output: Length: 5 print(\"Min:\", min(numbers)) #Output: Min: -1 print(\"Max:\", max(numbers)) #Output: Max: 100 print(\"Sum:\", sum(numbers)) #Output: Sum: 242 print(\"Mean:\", sum(numbers) / len(numbers)) #Output: Mean: 48.4","title":"Built-in functions and lists"},{"location":"chapter/05.html#lists-and-strings","text":"One can break a string into its parts through the method split For instance, if a string represents a text, one can see break into its words One can access a particular word or loop through all the words names = \"Alice, Sophie, Bob, Eve\" students = names.split(\",\") print(students) One might also want to join the elements of a list to represent as a single string This can be done through the method join of a string students = [\"Alice\", \"Sophie\", \"Bob\", \"Eve\"] print(\";\".join(students)) Output the name of the students separated by a semicolon. numbers = list(range(10)) print(\",\".join(str(i) for i in numbers))","title":"Lists and strings"},{"location":"chapter/05.html#objects-and-values","text":"When one assigns a variable to another, both variables will refer to the same object a = [1, 8, 10] b = a In this case, we case a list has two different names a and b . Changes made with one will affect the other. This behavior is called aliasing . b[0] = 7 print(a) # [7, 8, 10] Although this behavior can be useful, it is sometimes unexpected or undesirable. In general, it is safer to avoid aliasing when you are working with mutable objects .","title":"Objects and values"},{"location":"chapter/05.html#cloning-lists","text":"If you want to modify a list and also keep a copy of the original one, you need to work on a copy the list. This process is sometimes called cloning . The easiest way to clone a list is to use the slice operator . a = [1, 8, 10] b = a[:] print(b) Taking any slice of the list a creates a new list. In this case, the slice happens to consist the whole list. Now, you can change the list b without affecting the list a . b[0] = 7 print(a) # [1, 8, 10]","title":"Cloning lists"},{"location":"chapter/05.html#list-as-parameters","text":"Passing a list as an argument of a function actually passes a reference to the list and not a copy of it. For example, the function head takes a list as a parameter and returns the first element: def head(list): return list[0] numbers = [1, 8, 10] head(numbers) In this case, the parameter list and the variable numbers refer to the same object. If a function modifies a list parameter, the caller sees the change. For example, the function delete_head removes the first element from a given list. def delete_head(list): del list[0] numbers = [1, 8, 10] delete_head(numbers) print(numbers) # [8, 10] In the same context, if a function returns a list, it returns a reference to the list.","title":"List as parameters"},{"location":"chapter/05.html#tuples","text":"Tuples are another kind of sequence that works much like a list Tuples have elements which are indexed starting at 0 Pretty much anything we can do to a list that doesn't change its state, we can do to a tuple We can specify a tuple by using parentheses or nothing instead of square brackets cheeses = ('Cheddar', 'Mozzarella', 'Burrata') students = ('Alice', 'Elsa', 'Mary', 'Eve') Tuples are a convenient way to return multiple values from a function Tuple contents are ordered (like an array). s = ('GOOG', 100, 490.1) name = s[0] # 'GOOG' shares = s[1] # 100 price = s[2] # 490.1 Unlike a list, once we created a tuple, we cannot alter its contents s[1] = 75 One will get the error \" TypeError: object does not support item assignment \"","title":"Tuples"},{"location":"chapter/05.html#tuples-are-more-memory-efficient","text":"Since Python does not have to build tuple structures to be modifiable, they are simpler and more efficient in terms of memory use and performance than lists Thus, in our program when we are making ``temporary variables'', we prefer tuples over lists","title":"Tuples are more memory efficient"},{"location":"chapter/05.html#tuples-are-comparable","text":"The comparison operators work with tuples and other sequences (\\eg{} lists) If the first item is equal, Python goes on to the next element, and so on, until it finds elements that differ numbers = (1, 5, 8) print (numbers < (6, 10, 15)) You can, however, make a new tuple based on a current tuple. s = (s[0], 75, s[2])","title":"Tuples are comparable"},{"location":"chapter/05.html#tuple-unpacking","text":"To use the tuple elsewhere, you can unpack its parts into variables. name, shares, price = s print('Cost', shares * price) The number of variables on the left must match the tuple structure. name, shares = s # ERROR Traceback (most recent call last): ... ValueError: too many values to unpack","title":"Tuple Unpacking"},{"location":"chapter/05.html#dictionaries","text":"A dictionary is another fundamental data structure in Python It stores information in key-value pairs It associates values with keys It enables one to quickly retrieve the value corresponding to a given key Dictionaries are like lists except that they use keys instead of numbers to look up values You can define them explicitly using key:value pairs and curly braces. mountains = {'Mount Everest': 8848, 'K2': 8611, 'Kangchenjunga': 8586}","title":"Dictionaries"},{"location":"chapter/05.html#adding-new-key-value-pairs","text":"To add a new key-value pair, you give the dictionary a name followed by the new key in square brackets, and set that equal to the new value. mountains = dict() mountains['Mount Everest'] = 8848 mountains['K2'] = 8611 mountains['Kangchenjunga'] = 8586 Dictionaries do not store their information in any particular order, so you may not get your information back in the same order you entered it. We can get individual items out of the dictionary by giving the dictionary\u2019s name, followed by the key in square brackets: print(mountains['Mount Everest']) Dictionaries have their own for loop syntax, since there are two kinds of information in dictionaries: the key and the value. The general syntax is: for key, value in dictionary_name.items(): print(key, value) For example, for mountain, altitude in mountains.items(): print(mountain, altitude) The method items returns a list of tuples, where each tuple is a key-value pair. If you want, you can also get a list of keys of a dictionary through its method keys names = mountains.keys() Similarly, you can also get a list of values through the method values altitudes = mountains.values() If you attempt to access an entry that is not in the dictionary, Python will return an error. mountains['Lhotse'] Python will return the following error: Traceback (most recent call last): KeyError: 'Lhotse' To check if an entry is in the dictionary use the .get(key) function, which returns the value or None if the key is not in the dictionary. print(mountains.get('Lhotse'))","title":"Adding new key-value pairs"},{"location":"chapter/05.html#modifying-values-in-a-dictionary","text":"Modifying a value in a dictionary is similar to modifying an element in a list. You give the name of the dictionary and then the key in square brackets, and set that equal to the new value. mountains['Lhotse'] = 8516","title":"Modifying values in a dictionary"},{"location":"chapter/05.html#removing-key-value-pairs","text":"You can remove a key-value pairs from a dictionary using the same del command you learned to use with lists. In this case, you give the del command, followed by the name of the dictionary, with the key that you want to delete. This removes the key and the value as a pair. del mountains['Lhotse']","title":"Removing key-value pairs"},{"location":"chapter/06.html","text":"Searching and Sorting The Boolean operator in tests the membership in a sequence . cheeses = [\"Cheddar\", \"Edam\", \"Gouda\", \"Feta\"] print(\"Edam\" in cheeses) print(\"Manouri\" in cheeses) Since Edam is a member of the list cheeses , the in operator returns True . It returns False for Manouri , since it is not a member of the list cheeses . We can combine not with in to test whether an element is not a member of the list print(\"Manouri\" not in cheeses) In this case, the output is True . The method sort arranges the elements of the list in ascending order cheeses.sort() It changes the list in-place. You can use the built-in function sorted to create a sorted version of a given list b_sorted = sorted(b) Exercises 1. Write a program that reads a set of integers from the user and store them in a list. The program should continue reading until the user enters the work done . Then, it should output all the values entered by the user in ascending order. Show the answer values = [] line = input(\"Enter an integer value (done to quite): \") while line != \"done\": value = int(line) values.append(value) line = input(\"Enter an integer value (done to quite): \") values.sort() print(values) 2. Write a program that reads words from the user until the user enters a blank line. The program should output each word entered by the user exactly once. The words should be outputted in the same order they were informed. Show the answer words = [] word = input(\"Enter a word (blank line to quit): \") while word != \"\": if word not in words: words.append(word) word = input(\"Enter a word (blank line to quit): \") print(words) 3. A standard deck of playing cards contains 52 cards. Each card has one of four suits along with a value. The suits are normally spades, hearts, diamonds and clubs while the values are 2 through 10, Jack, Queen, King and Ace. Each playing card can be represented using two characters. The first character is the value of the card, with the values 2 through 9 being represented directly. The characters T, J, Q, K, and A are used to represent the values 10, Jack, Queen, King and Ace respectively. The second character is used to represent the suit of the card. It is normally a lowercase letter: s for spades, h for hearts, d for diamonds, and c for clubs. The following table provides several examples of cards and their two-character representations. Card Abbreviation Jack of spades Js Two of clubs 2c Ten of diamonds Td Ace of hearts Ah Nine of spades 9s Begin by writing a function named _create_deck_. It uses loops to create a complete deck of cards by storing the two-character abbreviations for all 52 cards into a list. Return the list of cards as the function's result. The function should not require any parameters. Write a second function named _shuffle_ that randomizes the order of the cards in a list. One technique that can be used to shuffle the cards is to visit each element in the list and swap it with another random element in the list. You must write your own loop for shuffling the cards , and you cannot make use of Python's built-in shuffle function. Use these functions to create a program that displays a deck of cards before and after it has been shuffled. A good shuffling algorithm is unbiased, meaning that every different arrangement of the elements is equally probable when the algorithm completes. While the approach described previously suggested visiting each element in sequence and swapping it with an element at a random index, such an algorithm is biased. In particular, elements that appear later in the original list are more likely to end up later in the shuffled list. Counterintuitively, an unbiased shuffle can be achieved by visiting each element in sequence and swapping it to a random index between the position of the current element and the end of the list instead of randomly selecting any index. Show the answer from random import randrange def create_deck(): cards = [] for suit in [\"s\", \"h\", \"d\", \"c\"]: for value in list(range(2,10)) + [\"T\", \"J\", \"Q\", \"K\", \"A\"]: # Construct the card and add it to the list cards.append(value + suit) return cards def shuffle(cards): for i in range(len(cards)): # Pick a random index between the current index and the end of the list other_pos = randrange(i, len(cards)) tmp = cards[i] cards[i] = cards[other_pos] cards[other_pos] = tmp def main(): cards = create_deck() print(f\"The original deck of cards is: \\n{cards}\\n\") shuffle(cards) print(f\"The shuffled deck of cards is: \\n{cards}\\n\") # Call the main function only if this code has not been imported into another program if __name__ == \"__main__\": main()","title":"3. Searching and Sorting"},{"location":"chapter/06.html#searching-and-sorting","text":"The Boolean operator in tests the membership in a sequence . cheeses = [\"Cheddar\", \"Edam\", \"Gouda\", \"Feta\"] print(\"Edam\" in cheeses) print(\"Manouri\" in cheeses) Since Edam is a member of the list cheeses , the in operator returns True . It returns False for Manouri , since it is not a member of the list cheeses . We can combine not with in to test whether an element is not a member of the list print(\"Manouri\" not in cheeses) In this case, the output is True . The method sort arranges the elements of the list in ascending order cheeses.sort() It changes the list in-place. You can use the built-in function sorted to create a sorted version of a given list b_sorted = sorted(b)","title":"Searching and Sorting"},{"location":"chapter/06.html#exercises","text":"1. Write a program that reads a set of integers from the user and store them in a list. The program should continue reading until the user enters the work done . Then, it should output all the values entered by the user in ascending order. Show the answer values = [] line = input(\"Enter an integer value (done to quite): \") while line != \"done\": value = int(line) values.append(value) line = input(\"Enter an integer value (done to quite): \") values.sort() print(values) 2. Write a program that reads words from the user until the user enters a blank line. The program should output each word entered by the user exactly once. The words should be outputted in the same order they were informed. Show the answer words = [] word = input(\"Enter a word (blank line to quit): \") while word != \"\": if word not in words: words.append(word) word = input(\"Enter a word (blank line to quit): \") print(words) 3. A standard deck of playing cards contains 52 cards. Each card has one of four suits along with a value. The suits are normally spades, hearts, diamonds and clubs while the values are 2 through 10, Jack, Queen, King and Ace. Each playing card can be represented using two characters. The first character is the value of the card, with the values 2 through 9 being represented directly. The characters T, J, Q, K, and A are used to represent the values 10, Jack, Queen, King and Ace respectively. The second character is used to represent the suit of the card. It is normally a lowercase letter: s for spades, h for hearts, d for diamonds, and c for clubs. The following table provides several examples of cards and their two-character representations. Card Abbreviation Jack of spades Js Two of clubs 2c Ten of diamonds Td Ace of hearts Ah Nine of spades 9s Begin by writing a function named _create_deck_. It uses loops to create a complete deck of cards by storing the two-character abbreviations for all 52 cards into a list. Return the list of cards as the function's result. The function should not require any parameters. Write a second function named _shuffle_ that randomizes the order of the cards in a list. One technique that can be used to shuffle the cards is to visit each element in the list and swap it with another random element in the list. You must write your own loop for shuffling the cards , and you cannot make use of Python's built-in shuffle function. Use these functions to create a program that displays a deck of cards before and after it has been shuffled. A good shuffling algorithm is unbiased, meaning that every different arrangement of the elements is equally probable when the algorithm completes. While the approach described previously suggested visiting each element in sequence and swapping it with an element at a random index, such an algorithm is biased. In particular, elements that appear later in the original list are more likely to end up later in the shuffled list. Counterintuitively, an unbiased shuffle can be achieved by visiting each element in sequence and swapping it to a random index between the position of the current element and the end of the list instead of randomly selecting any index. Show the answer from random import randrange def create_deck(): cards = [] for suit in [\"s\", \"h\", \"d\", \"c\"]: for value in list(range(2,10)) + [\"T\", \"J\", \"Q\", \"K\", \"A\"]: # Construct the card and add it to the list cards.append(value + suit) return cards def shuffle(cards): for i in range(len(cards)): # Pick a random index between the current index and the end of the list other_pos = randrange(i, len(cards)) tmp = cards[i] cards[i] = cards[other_pos] cards[other_pos] = tmp def main(): cards = create_deck() print(f\"The original deck of cards is: \\n{cards}\\n\") shuffle(cards) print(f\"The shuffled deck of cards is: \\n{cards}\\n\") # Call the main function only if this code has not been imported into another program if __name__ == \"__main__\": main()","title":"Exercises"},{"location":"chapter/07.html","text":"Recursion Remember, recursion is a problem-solving technique in which tasks are completed by reducing them into repeated, smaller tasks of the same form. It comprises two main components: the base and the recursive cases Fractals A fractal is any repeated, graphical pattern. It is composed of repeated instances of the same shape or pattern, arranged in a structured way. Drawing Fractals with the Turtle Graphics The turtle module provides some basic commands for drawing lines on the screen in an animated way. You can think it as a turtle holding a pen. The turtle has three attributes: a location , an orientation , and a pen . The pen has attributes color , width , and state . For example, the following code asks the turtle to draw a line 150 pixels long. import turtle pen = turtle.Turtle() pen.forward(150) You can also ask it to move forward, backward, and turn left and right, as well as to draw a circle: import turtle pen = turtle.Turtle() for i in range(360): pen.forward(1) pen.right(1) All functions available as part of the turtle library are available at https://docs.python.org/3/library/turtle.html . You can draw different geometric figures. For instance, you can instruct the turtle to draw the Koch snowflake following a recursive strategy. The base is a straight line The procedures to draw the first level include: Draw a line 1/3 the total length Rotate 60 degrees to the left Draw another line 1/3 the total length Rotate 120 degrees to the right Draw a third line 1/3 the total length Rotate 60 degrees to the left Draw a fourth and final line 1/3 the total length For the next level, you simply take one of the lines and draw a shrunken copy of the described procedure import turtle def koch(t, order, size): if order == 0: t.forward(size) else: koch(t, order-1, size/3) t.left(60) koch(t, order-1, size/3) t.right(120) koch(t, order-1, size/3) t.left(60) koch(t, order-1, size/3) def main(): pen = turtle.Turtle(shape=\"turtle\") screen = turtle.Screen() screen.title('Turtle Koch Curve') pen.color(\"green\") pen.shapesize(1) pen.penup() pen.speed('fastest') pen.backward(150) pen.pendown() koch(pen, 3, 300) screen.exitonclick() if __name__ == '__main__': main()","title":"4. Recursion"},{"location":"chapter/07.html#recursion","text":"Remember, recursion is a problem-solving technique in which tasks are completed by reducing them into repeated, smaller tasks of the same form. It comprises two main components: the base and the recursive cases","title":"Recursion"},{"location":"chapter/07.html#fractals","text":"A fractal is any repeated, graphical pattern. It is composed of repeated instances of the same shape or pattern, arranged in a structured way.","title":"Fractals"},{"location":"chapter/07.html#drawing-fractals-with-the-turtle-graphics","text":"The turtle module provides some basic commands for drawing lines on the screen in an animated way. You can think it as a turtle holding a pen. The turtle has three attributes: a location , an orientation , and a pen . The pen has attributes color , width , and state . For example, the following code asks the turtle to draw a line 150 pixels long. import turtle pen = turtle.Turtle() pen.forward(150) You can also ask it to move forward, backward, and turn left and right, as well as to draw a circle: import turtle pen = turtle.Turtle() for i in range(360): pen.forward(1) pen.right(1) All functions available as part of the turtle library are available at https://docs.python.org/3/library/turtle.html . You can draw different geometric figures. For instance, you can instruct the turtle to draw the Koch snowflake following a recursive strategy. The base is a straight line The procedures to draw the first level include: Draw a line 1/3 the total length Rotate 60 degrees to the left Draw another line 1/3 the total length Rotate 120 degrees to the right Draw a third line 1/3 the total length Rotate 60 degrees to the left Draw a fourth and final line 1/3 the total length For the next level, you simply take one of the lines and draw a shrunken copy of the described procedure import turtle def koch(t, order, size): if order == 0: t.forward(size) else: koch(t, order-1, size/3) t.left(60) koch(t, order-1, size/3) t.right(120) koch(t, order-1, size/3) t.left(60) koch(t, order-1, size/3) def main(): pen = turtle.Turtle(shape=\"turtle\") screen = turtle.Screen() screen.title('Turtle Koch Curve') pen.color(\"green\") pen.shapesize(1) pen.penup() pen.speed('fastest') pen.backward(150) pen.pendown() koch(pen, 3, 300) screen.exitonclick() if __name__ == '__main__': main()","title":"Drawing Fractals with the Turtle Graphics"}]}